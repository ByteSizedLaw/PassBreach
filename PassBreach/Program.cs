using PassBreach;

public class Program
{
    #region member variables
    #region readonly variables
    private static readonly string systemPrefix = "[SYSTEM]";
    private static readonly string[] hashingAlgs = new string[2] { "SHA256", "MD5" };
    private static readonly char[] charsExtended = new char[91] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '`', '~', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '{', '}', ':', '<', '>', '/', '\\', '\'', '"', '[', ']', ',', '.', ' ', ';' };
    private static readonly char[] charsLong = new char[15] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o' };
    private static readonly char[] charsMedium = new char[5] { 'a', 'b', 'c', 'd', 'e' };
    private static readonly char[] charsShort = new char[3] { 'a', 'b', 'c' };
    private static readonly List<char[]> TotalChars = new List<char[]>() { charsShort, charsMedium, charsLong, charsExtended };
    private static readonly Dictionary<char[], string> descriptionOfCharSets = new Dictionary<char[], string>() { { charsShort, "English Characters, A-C" }, { charsMedium, "English Characters, A-E" }, { charsLong, "English Characters, A-O" }, { charsExtended, "English Characters, A-Z, with extra symbols" } };
    private static readonly char[] chars = GetUserSelectedCharsArray();
    private static readonly int lengthOfCharsArr = chars.Length;
    #endregion readonly variables

    #region configurable variables
    private static int passLength = 0;
    private static string hashToUse = "";
    private static string userInputHash = "";
    private static string autoGeneratedInputThatGaveUsOurHash = "";
    private static string userInputPassword = "";
    #endregion configurable variables
    #endregion member variables

    #region Controller and start methods
    /// <summary>
    /// Main logic of the app, called at startup and handles all functionality
    /// </summary>
    /// <param name="args"></param>
    private static void Main(string[] args)
    {
        //clear up all variables
        ClearAllVariables();

        //save our user's input -> this will also gen a (SHA256 or MD5, for now) hash for their password
        LoadUserInput();

        // Main reverse engineering logic
        if (userInputHash.Equals(""))
        {
            Controller_BruteForcer();
        }
        else
        {
            Controller_BruteForcer_Hash();
        }

        //write output to console
        WriteFinalOutput();

        //clear up all variables
        ClearAllVariables();
    }

    /// <summary>
    /// Main logic for our reverse engineering.
    /// <br></br>
    /// This function will trigger the reverse engineering process and find the original hash based on the given inputs
    /// </summary>
    public static void Controller_BruteForcer()
    {
        IHashAlgorithm alg = FindSelectedHashAlg();
        string targetHash = CalculateHash.GetHash(userInputPassword, alg);
        var queueManager = new ConcurrentQueueManager();

        Console.WriteLine($"{systemPrefix} Hash of password \"{userInputPassword}\" was: {alg.ComputeHash(userInputPassword)}. \r\n{systemPrefix} Reverse-engineering password hash..");

        //seed initial queue
        foreach (char c in chars)
        {
            queueManager.Enqueue(c.ToString());
        }

        var cracker = new HashCracker(queueManager, alg, targetHash, chars, passLength);

        autoGeneratedInputThatGaveUsOurHash = cracker.CrackPassword();
    }
    public static void Controller_BruteForcer_Hash()
    {
        IHashAlgorithm alg = FindSelectedHashAlg();
        var queueManager = new ConcurrentQueueManager();

        Console.WriteLine($"{systemPrefix} Reverse-engineering password hash..");

        Console.WriteLine($"Hash Algorithm: {alg.GetType().Name}");
        Console.WriteLine($"User Input Hash: {userInputHash}");
        Console.WriteLine($"Character Set: {new string(chars)}");
        Console.WriteLine($"Password Length: {passLength}");

        //seed initial queue
        foreach (char c in chars)
        {
            queueManager.Enqueue(c.ToString());
        }

        var cracker = new HashCracker(queueManager, alg, userInputHash, chars, passLength);

        autoGeneratedInputThatGaveUsOurHash = cracker.CrackPassword();
        Console.WriteLine($"Generated Input: {autoGeneratedInputThatGaveUsOurHash}");
    }


    private static IHashAlgorithm FindSelectedHashAlg()
    {
        if (hashToUse == hashingAlgs[0])
        {
            return new SHA256HashAlgorithm();
        }
        else if (hashToUse == hashingAlgs[1])
        {
            return new Md5Algorithm();
        }
        else
        {
            return null;
        }
    }

    /// <summary>
    /// Clears variables across runs for memory management. 
    /// </summary>
    private static void ClearAllVariables()
    {
        userInputHash = "";
        autoGeneratedInputThatGaveUsOurHash = "";
        hashToUse = "";
        passLength = 0;
    }
    private static void WriteFinalOutput()
    {
        if (!autoGeneratedInputThatGaveUsOurHash.Equals(""))
        {
            Console.WriteLine($"{systemPrefix} The User's password was: {autoGeneratedInputThatGaveUsOurHash}");
        }
        else
        {
            Console.WriteLine($"{systemPrefix} Couldn't reverse engineer the user's password. Please check the given password length");
        }
        Console.Read(); //just keep the app open until the user has closed it (gives them a chance to read everything)
    }

    #endregion Controller and start methods

    #region Load user config and thresholds
    private static void LoadUserInput()
    {
        hashToUse = GetUserSelectedHashAlgorithm();

        //check if they already have a hash they want to reverse-engineer, and then handle that if they do
        if (HandleUserAlreadyHasHashToCalc())
        {
            return;
        }

        passLength = GetUserDesiredPassLength();
        LoadUserPasswordText();
    }
    private static char[] GetUserSelectedCharsArray()
    {
        Console.WriteLine($"{systemPrefix} Please choose a set of characters to use for reverse-engineering. \r\n{systemPrefix} There are currently {TotalChars.Count} sets to choose from. Pick a number between 1 and {TotalChars.Count}. " +
                          $"\r\n{systemPrefix} Please note: The more characters we use, the higher the resource costs of reverse-engineering will be." +
                          $"{systemPrefix} These are the currently available options: ");
        int leng = TotalChars.Count;
        for (int i = 0; i < leng; i++)
        {
            Console.WriteLine($"Set {i + 1}. Number of characters: {TotalChars[i].Length}. Description: {descriptionOfCharSets[TotalChars[i]]}");
        }
        Console.WriteLine($"{systemPrefix} Please enter your selection:");

        return TotalChars[LoadUserSelectedCharsArray()];
    }
    private static int LoadUserSelectedCharsArray()
    {
        string? strRep = Console.ReadLine();
        try
        {
            if (!String.IsNullOrEmpty(strRep))
            {
                return (int.Parse(strRep) - 1);
            }
            return LoadUserSelectedCharsArray();
        }
        catch
        {
            return 0;
        }
    }
    private static bool HandleUserAlreadyHasHashToCalc()
    {
        //check if they already have a hash they want to reverse-engineer
        if (CheckIfUserPredefinedPwordHash())
        {
            //find out what the hash is
            userInputHash = GetuserPredefinedPwordHash();

            //find out how many characters they want to calculate/iterate for
            passLength = GetUserUpperLimitOfChars();

            //if the pword is 0, we need to basically just let it loop until it finds an answer. Easiest way of doing this would be to overwrite the user's input to 64 chars (current upper limit for most pwords)
            if (passLength == 0)
            {
                passLength = 64;
            }

            //we need to tell the app to skip asking the user for input and calculating a new hash now, because we already have one
            return true;
        }
        //else
        //do the regular operations
        return false;
    }
    private static int GetUserUpperLimitOfChars()
    {
        Console.WriteLine($"{systemPrefix} Please enter the maximum number of password characters to reverse-engineer for. \r\n{systemPrefix} Please Note: Higher values result in more resource usage, and using 0 will default the app to run until it finds an answer, with no upper limit. \r\n{systemPrefix} Very Important Note: Please monitor your resources closely, and use a reasonable threshold, as this can be hazardous for your computer");
        int finalAns = LoadUserUpperLimitOfChars();

        return finalAns;
    }
    private static int LoadUserUpperLimitOfChars()
    {
        string? strRep = Console.ReadLine();
        try
        {
            if (!String.IsNullOrEmpty(strRep))
            {
                return int.Parse(strRep);
            }
            return LoadUserUpperLimitOfChars();
        }
        catch
        {
            return 0;
        }
    }
    private static string GetuserPredefinedPwordHash()
    {
        Console.WriteLine($"{systemPrefix} Please enter the Hash to Reverse-Engineer:");
        string finalAns = LoadUserPredefinedHashInput();

        return finalAns;
    }
    private static string LoadUserPredefinedHashInput()
    {
        string? strRep = Console.ReadLine();
        try
        {
            if (!String.IsNullOrEmpty(strRep))
            {
                return strRep.ToLower(); //some places use a hash that has uppercase characters, it's meant to be lowercase lol
            }
            return LoadUserPredefinedHashInput();
        }
        catch
        {
            return string.Empty;
        }
    }
    private static bool CheckIfUserPredefinedPwordHash()
    {
        Console.WriteLine($"{systemPrefix} Do you already have a Hex-representation {hashToUse} Hash to reverse-engineer? \r\n{systemPrefix} Note: Please answer (Y/N) only");
        bool finalAns = UserHasPredefinedHashInput();

        return finalAns;
    }
    private static bool UserHasPredefinedHashInput()
    {
        bool finalAns = false;
        string? strRep = Console.ReadLine();
        try
        {
            if (!String.IsNullOrEmpty(strRep))
            {
                if (strRep.Equals("Y"))
                {
                    finalAns = true;
                    return finalAns;
                }
                else if (strRep.Equals("N"))
                {
                    finalAns = false;
                    return finalAns;
                }
            }
            return UserHasPredefinedHashInput();
        }
        catch
        {
            return false;
        }
    }
    private static int GetUserDesiredPassLength()
    {
        Console.WriteLine($"{systemPrefix} Please insert the length of the password you want to crack (example: 3) \r\n{systemPrefix} Note: The longer the password is, the more time it will take to crack.");
        int finalAns = LoadUserPassLengInput();

        return finalAns;
    }
    private static int LoadUserPassLengInput()
    {
        string? strRep = Console.ReadLine();
        try
        {
            if (!String.IsNullOrEmpty(strRep))
            {
                //we're just going to assume that the user gave an actual number >= 1
                return int.Parse(strRep);
            }
            return LoadUserPassLengInput();
        }
        catch
        {
            return 0;
        }
    }
    private static string GetUserSelectedHashAlgorithm()
    {
        string str = "";
        int hashAlgsCount = hashingAlgs.Count();
        int hashAlgsCountMin1 = hashingAlgs.Count() - 1;

        for (int i = 0; i < hashAlgsCountMin1; i++)
        {
            str += hashingAlgs[i] + ", ";
        }
        str += hashingAlgs[hashAlgsCountMin1];


        Console.WriteLine($"{systemPrefix} The currently available hash algorithms are: {str}.\r\n{systemPrefix} You have {hashAlgsCount} options to choose from. Please select a number between 1 and {hashAlgsCount}");

        string? s = LoadUserSelectedHashAlgorithm();
        Console.WriteLine($"{systemPrefix} Selected hashing algorithm: {s}");

        return s;
    }
    private static string? LoadUserSelectedHashAlgorithm()
    {
        string? s = Console.ReadLine();
        try
        {
            if (!String.IsNullOrEmpty(s))
            {
                //we're just going to assume that the user gave an actual number >= 1
                s = hashingAlgs[int.Parse(s) - 1];
                return s;
            }
            return LoadUserSelectedHashAlgorithm();
        }
        catch
        {
            return "";
        }
    }
    private static void LoadUserPasswordText()
    {
        string str = "";
        foreach (char c in chars)
        {
            if (c == chars[chars.Length - 1])
            {
                str += "and " + c;
                continue;
            }
            str += c + ", ";
        }
        Console.WriteLine($"{systemPrefix} These are the {str.Length} characters that you can use to create a {passLength} character-long password:\r\n[ {str} ]");
        Console.WriteLine($"{systemPrefix} Please enter a password:");

        HandleSpecificLogicBasedOnSelectedHashAlg(0);
    }
    private static void HandleSpecificLogicBasedOnSelectedHashAlg(int step)
    {
        //get user Password text
        string? s = Console.ReadLine();

        userInputPassword = s;
    }
    #endregion Load user config and thresholds
}